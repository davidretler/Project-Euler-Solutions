/*
Problem 12
The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?
*/

#include <stdio.h>
#include <stdbool.h>
#include <math.h>
#include <stdlib.h>

long triangle_number(long n);
bool is_prime(long long int num);
long next_prime(long p);
long n_divisors(long n);
int factors(long n, long *fac_matrix);

int main(void)
{
	long n = 1;
	long div;
	bool done = false;
	while(!done)
	{
		n++;
		div = n_divisors(triangle_number(n));
		printf("%ld\t%ld\n",triangle_number(n), div);
		if(div > 500) done = true;
	}
	
	printf("%ld is the lowest triangle number with more then 500 divisors", triangle_number(n));
	
	return 0;
}

//Returns the nth triangle number, O(1)
//Explicit form makes this one pretty efficient
long triangle_number(long n)
{
	//Explicit closed form
	return n*(n+1)/2;
}

//Returns true if a number is prime, O(sqrt(n))
//This naive algorithm works by trial division rather than anything fancy.
bool is_prime(long long int num)
{
	long long int max = ceil(sqrt(num));
	long long int n = 2;
	bool prime = true;
	
	while(n <= max)
	{
		if(num % n == 0 && num != n)
		{			
			prime = false;
			break;
		}
		n++;
	}
	
	return prime;
}

//Returns the first prime after p
long next_prime(long p)
{
	//if p is even, add one. if p is odd, add two.
	p += (p % 2 == 0) ? 1 : 2;
	while(!is_prime(p))
	{
		p+=2;
	}
	return p;
}

//Returns the number of divisors in n, O(log n) I think (divide and conquer) 
//This takes the number and finds the multiplicity of each prime factor. Once that has been 
//accomplished, we find the total number of divisors by taking the product of each element + 1.
//For example 12 => {2, 1, 0, 0,...} so n_divisors(12) = (2+1)*(1+1)*(0+1)*... = 3*2*1*1*... = 6.
//Because we only need to find the prime factors rather than every factor from trial division, we
//have a much more efficient method.
long n_divisors(long n)
{
	//long l = ceil(n - sqrt(n));
	//256289 is a decently large size that was capable of holding everything I needed without
	//breaking anything. I was decently surprised when this program executed as quickly as it did
	//considering how large this number is. The answer is the 12375th triangle number, meaning this
	//function was called that many times.
	long fac_matrix[256289];
	for(int i = 0; i < 256289; i++)
	{
		fac_matrix[i] = 0;
	}
	
	factors(n, fac_matrix);
	
	long prod = 1;
	for(int i = 0; i < 256289; i++)
	{
		prod = prod * (fac_matrix[i] + 1);
	}
	
	return prod;
}

//Fills the matrix passed with the divisors
//Basically find the lowest prime factor. Increment the corresponding element in the matrix by one,
//divide the number by the factor and recursively factor that. If there is no prime factor let, then
//we're done. The result is a matrix that contains the multiplicity of each prime factor (0 if not a
//factor. For example, factors(12, m) would make m = {2, 1, 0, 0,...} because 12 = 2^2 * 3^1.
int factors(long n, long *fac_matrix)
{
	long test = 2;
	long ith_prime = 0;
	//while the number is not divisible by the current prime
	while(n % test != 0 && n > test)
	{
		//take the next prime
		test = next_prime(test);
		ith_prime++;
		
	}
	if(n >= test)
	{
		//increment the current factor
		fac_matrix[ith_prime] += 1;
		//recursively factor the number divided by the current factor
		factors(n/test, fac_matrix);
	}
	
	return 0;

}
