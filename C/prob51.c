/*
  Problem 51
  By replacing the 1st digit of the 2-digit number *3, it turns out that six of the nine possible values: 13, 23, 43, 53, 73, and 83, are all prime.

  By replacing the 3rd and 4th digits of 56**3 with the same digit, this 5-digit number is the first example having seven primes among the ten generated numbers, yielding the family: 56003, 56113, 56333, 56443, 56663, 56773, and 56993. Consequently 56003, being the first member of this family, is the smallest prime with this property.

  Find the smallest prime which, by replacing part of the number (not necessarily adjacent digits) with the same digit, is part of an eight prime value family.
*/


#define FAMILY 8
//#define DEBUG

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "prime_2.h"



void find_possible_subs(bool **index, int max_i);
long replace_digits(long num, bool *index, int new_digit);
long check(long num);

int main(void)
{
    //as usual, this takes 99% of the execution time
    initialize_primes();

    int index_p = 0;
    while(check(prime(index_p)) == -1)
    {
	index_p++;
    }

    printf("First number to fit the criteria: %ld\n", check(prime(index_p)));
    
    return 0;
}

/*
  Checks all the possible subs for digits in num with digit
  if FAMILY different numbers have this property, then we're clear
  In particular this function returns the first member of the family
*/
long check(long num)
{
    int digits = n_digits(num);
    bool **index;
    long rows = (long)ceil(pow(2,digits));
    //allocate room for the pointers
    index = (bool**)malloc(rows * sizeof *index);
    for(int i = 0; i < rows; i++)
    {
	//have each pointer point to the array of bool values representing digit swaps
	index[i] = (bool*)malloc(digits * sizeof *index[i]);
    }
    //find all the possible digit swaps
    find_possible_subs(index, digits);
    //iterate over the digits to replace
    for(int row = 0; row < rows; row++)
    {
	int count = 0;
	int first_val = -1;
	//iterate over all the possible digit to swap to
	for(int curr_digit = 0; curr_digit <= 9; curr_digit++)
	{
	    long swapped = replace_digits(num, index[row], curr_digit);
	    //if the number is prime AND we didn't add a leading 0 (which doesn't count)
	    if(is_prime(swapped) && !(curr_digit == 0 && index[row][0]))
	    {
		//count the number of different primes generated by this family
		if(count == 0) first_val = curr_digit;
		count++;
#ifdef DEBUG
		printf("%ld\t", swapped);
#endif
	    }
	}
#ifdef DEBUG
	printf("\n");
#endif
	//if the sequence was part of the family
	if(count == FAMILY)
	{
	    //return the first member of the family
	    return replace_digits(num, index[row], first_val);
	}
    }

    return -1;
}

/*
  Fills the **index double array with a "truth table" of the digits to swap
*/
void find_possible_subs(bool **index, int max_i)
{
    
    //essentially the columns of the true table
    for(int col = 0; col < max_i; col++)
    {
	bool curr_value = true;
	int curr_index = 0;
       	int max_row = (long)ceil(pow(2, max_i));
	int swap = max_row/(long)ceil(pow(2, col + 1));
	//true table rows
	for(int row = 0; row < max_row; row++)
	{
	    if(curr_index == swap)
	    {
		curr_value = !curr_value;
		curr_index = 0;
	    }
	    index[row][col] = curr_value;
	    curr_index++;
#ifdef DEBUG
	    printf("%d\t", curr_value);
#endif
	}
#ifdef DEBUG
	printf("\n");
#endif
    }   
}

/*
  Replaces the digit at index in num to new_digit and returns the result
*/
long replace_digits(long num, bool *index, int new_digit)
{
    int digits = n_digits(num);
    char num_s[digits + 1];
    sprintf(num_s, "%ld", num);
    //num_s[index] = new_digit + '0';
    
    for(int i = 0; i < digits; i++)
    {
	if(index[i])
	{
	    num_s[i] = new_digit + '0';
	}
    }
    
    return atol(num_s);
}
